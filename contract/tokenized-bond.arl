/**
* Private    : only owner or minter can mint
* Multiple   : multiple collection
**/
archetype tokenized_bond(owner : address)
with metadata ""

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

constant CALLER_NOT_OWNER                        : string = "CALLER_NOT_OWNER"
constant CONTRACT_PAUSED                         : string = "CONTRACT_PAUSED"
constant CONTRACT_NOT_PAUSED                     : string = "CONTRACT_NOT_PAUSED"
constant EXPIRY_TOO_BIG                          : string = "EXPIRY_TOO_BIG"
constant FA2_INSUFFICIENT_BALANCE                : string = "FA2_INSUFFICIENT_BALANCE"
constant FA2_INVALID_AMOUNT                      : string = "FA2_INVALID_AMOUNT"
constant FA2_NOT_OPERATOR                        : string = "FA2_NOT_OPERATOR"
constant MISSIGNED                               : string = "MISSIGNED"
constant NO_ENTRY_FOR_USER                       : string = "NO_ENTRY_FOR_USER"
constant PERMIT_EXPIRED                          : string = "PERMIT_EXPIRED"
constant PERMIT_NOT_FOUND                        : string = "PERMIT_NOT_FOUND"
constant PERMIT_USER_NOT_FOUND                   : string = "PERMIT_USER_NOT_FOUND"
constant SIGNER_NOT_FROM                         : string = "SIGNER_NOT_FROM"
constant NO_DOUBLE_MINTING                       : string = "TOKEN_ID_ALREADY_MINTED"
constant NO_INTER_TRANSFER                       : string = "NO_INTER_TRANSFER"
constant INTER_TRANSFER_PAUSED                   : string = "INTER_TRANSFER_PAUSED"
constant INTER_TRANSFER_NOT_PAUSED               : string = "INTER_TRANSFER_NOT_PAUSED"
constant NO_INTER_TRANSFER_AFTER_EXPIRY          : string = "NO_INTER_TRANSFER_AFTER_EXPIRY"
constant INTER_TRANSFER_AFTER_EXPIRY_PAUSED      : string = "INTER_TRANSFER_AFTER_EXPIRY_PAUSED"
constant INTER_TRANSFER_AFTER_EXPIRY_NOT_PAUSED  : string = "INTER_TRANSFER_AFTER_EXPIRY_NOT_PAUSED"
constant TOKEN_FROZEN                            : string = "TOKEN_FROZEN"
constant TOKEN_NOT_FROZEN                        : string = "TOKEN_NOT_FROZEN"
constant MINTER_IS_OPERATOR                      : string = "MINTER_IS_OPERATOR"
constant MINTER_IS_NOT_OPERATOR                  : string = "MINTER_IS_NOT_OPERATOR"

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

/**
* Transfer candidate for ownership
* @param candidate address
*/
entry transfer_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

/**
* Accept ownership of the contract
* Note: fails if caller is not declared candidate
*/
entry accept_ownership() {
  called by get_some(owner_candidate)
  effect {
    owner := get_some(owner_candidate);
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Contract execution pause/resume
//----------------------------------------------------------------------------

variable paused : bool = false

/**
 * Pause the contract execution
 */
entry pause() {
  called by owner
  effect {
    do_require(not paused, CONTRACT_PAUSED);
    paused := true
  }
}

/**
 * Resume the contract execution
 */
entry unpause() {
  called by owner
  effect {
    do_require(paused, CONTRACT_NOT_PAUSED);
    paused := false
  }
}

/**
 * Asserts that the contract execution is not paused
 */
function is_not_paused() : bool {
  if (not paused)
  then return true
  else fail(CONTRACT_PAUSED)
}



//----------------------------------------------------------------
// INTER TRANSFER PAUSE AND RESUME
//----------------------------------------------------------------

/**
 * Pause the contract execution
 */
entry pause_inter_transfer(itoken_id: nat) {
  called by owner
  effect {
    do_require(not token_metadata[itoken_id].token_itr_paused, INTER_TRANSFER_PAUSED);
    token_metadata[itoken_id].token_itr_paused := true
  }
}

/**
 * Resume the contract execution
 */
entry resume_inter_transfer(itoken_id: nat) {
  called by owner
  effect {
    do_require(token_metadata[itoken_id].token_itr_paused, INTER_TRANSFER_NOT_PAUSED);
    token_metadata[itoken_id].token_itr_paused := false
  }
}

//----------------------------------------------------------------
// INTER TRANSFER AFTER EXPIRY PAUSE AND RESUME
//----------------------------------------------------------------

/**
 * Pause inter transfer after expiry
 */
entry pause_itr_after_expiry(itoken_id: nat) {
  called by owner
  effect {
    do_require(not token_metadata[itoken_id].token_itr_expiry_paused, INTER_TRANSFER_AFTER_EXPIRY_PAUSED);
    token_metadata[itoken_id].token_itr_expiry_paused := true
  }
}

/**
 * Resume inter transfer after expiry
 */
entry resume_itr_after_expiry(itoken_id: nat) {
  called by owner
  effect {
    do_require(token_metadata[itoken_id].token_itr_expiry_paused, INTER_TRANSFER_AFTER_EXPIRY_NOT_PAUSED);
    token_metadata[itoken_id].token_itr_expiry_paused := false
  }
}

//----------------------------------------------------------------
// MINTER IS OPERATOR
//----------------------------------------------------------------

/**
 * Set minter as operator
 */
entry set_minter_as_operator(itoken_id: nat) {
  called by owner
  effect {
    do_require(not token_metadata[itoken_id].minter_is_operator, MINTER_IS_OPERATOR);
    token_metadata[itoken_id].minter_is_operator := true
  }
}

/**
 * Unset minter as operator
 */
entry unset_minter_as_operator(itoken_id: nat) {
  called by owner
  effect {
    do_require(token_metadata[itoken_id].minter_is_operator, MINTER_IS_NOT_OPERATOR);
    token_metadata[itoken_id].minter_is_operator := false
  }
}

//----------------------------------------------------------------
// FREEZE TRANSFER OF TOKEN
//----------------------------------------------------------------

/**
 * Freeze transfer of the token
 */
entry freeze_token(itoken_id: nat) {
  called by owner
  effect {
    do_require(not token_metadata[itoken_id].token_frozen, TOKEN_FROZEN);
    token_metadata[itoken_id].token_frozen := true
  }
}

/**
 * Resume transfer of the token
 */
entry unfreeze_token(itoken_id: nat) {
  called by owner
  effect {
    do_require(token_metadata[itoken_id].token_frozen, TOKEN_NOT_FROZEN);
    token_metadata[itoken_id].token_frozen := false
  }
}

/**
 * Asserts that the contract execution is not paused
 */
function is_not_frozen(itoken_id: nat) : bool {
  return (not token_metadata[itoken_id].token_frozen)
}

/**
* Asserts that the transfer has the minter as sender
*/

function minter_is_sender(%from: address, td: transfer_destination) : bool {
  var sender_is_token_minter = token_metadata[td.token_id_dest].token_minter = %from;
  var sender_is_a_minter = minters.contains(%from);
  return (sender_is_a_minter and sender_is_token_minter)
}

/**
* Asserts that the transfer has the minter as reciever
*/

function minter_is_reciever(%from: address, td: transfer_destination) : bool {
  var reciever_is_token_minter = token_metadata[td.token_id_dest].token_minter = td.to_dest;
  var reciever_is_a_minter = minters.contains(td.to_dest);
  return (reciever_is_a_minter and reciever_is_token_minter)
}


/**
* Asserts that the transfer has the minter of the token as party
*/

function at_least_a_minter(%from: address, td: transfer_destination) : bool {
  return (minter_is_sender(%from, td) or minter_is_reciever(%from, td))
}

/**
* Asserts that the transfer has the minter of the token as party if inter_transfer_paused = true
*/
function inter_transfer_allowed(%from: address, td: transfer_destination) : bool {
  return

  (if not token_metadata[td.token_id_dest].token_itr_paused
  then true
  else at_least_a_minter(%from, td))
}

/**
* Asserts that reciever is minter after expiry of the token
*/

function minter_is_reciever_after_expiry(%from: address, td: transfer_destination) : bool {
  return
  (if not token_metadata[td.token_id_dest].token_itr_expiry_paused then true
  else if token_metadata[td.token_id_dest].token_expiration_date >= now then true
  else minter_is_reciever(%from, td))
}

//----------------------------------------------------------------------------
// Metadata
//----------------------------------------------------------------------------

entry set_metadata(ikey: string, idata : bytes) {
  called by owner
  require { r3 : is_not_paused() }
  effect {
    metadata := put(metadata, ikey, idata)
  }
}

//----------------------------------------------------------------------------
// Minter role
//----------------------------------------------------------------------------

asset minters identified by minter {
  minter: address;
  tokens_minted: list<nat> = [];
}

entry add_minter(aminter: address) {
  called by owner
  require { r9: is_not_paused() }
  effect {
    minters.add_update(aminter, {})
  }
}

entry replace_minter(ominter: address, nminter: address) {
  called by owner
  require { 
    r10: is_not_paused();
    ominter_exists: minters.contains(ominter);
    nminter_does_not_exist: not minters.contains(nminter);
  }
  effect {
    // replace old minter with new minter in all minted tokens
    for tk in minters[ominter].tokens_minted do
      token_metadata.update(tk, {token_minter = nminter})
    done;
    // add new minter
    minters.add_update(nminter, { tokens_minted = minters[ominter].tokens_minted });
    // remove old minter
    minters.remove(ominter);
  }
}

//----------------------------------------------------------------------------
// Data types
//----------------------------------------------------------------------------

asset ledger identified by ltoken lowner to big_map {
  ltoken     : nat;
  lowner     : address;
  lamount    : nat = 0;
}

asset operator identified by oaddr otoken oowner to big_map {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
  ounit       : unit = Unit;
}

asset token_metadata to big_map {
  ftoken_metadata : nat;
  token_id        : nat;
  token_minter: address;
  token_interest: rational;
  token_expiration_date: date;
  token_info      : map<string, bytes>;
  token_itr_paused: bool;
  token_itr_expiry_paused: bool = true;
  token_frozen: bool = false;
  minter_is_operator: bool;
}

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
} as ((%to, (token_id, amount)))

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
} as ((owner, token_id))

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
} as ((request, balance))


asset permits to big_map {
  user_address : address;
  counter      : nat = 0;
}

asset operator_for_all identified by fa_oaddr fa_oowner to big_map {
  fa_oaddr    : address;
  fa_oowner   : address;
  fa_empty    : unit = Unit;
}

//----------------------------------------------------------------------------
// Operators
//----------------------------------------------------------------------------

/**
* Adds or removes operators for specified tokens
* @param upl list of add or remove operator specification
*/ 
entry update_operators (upl : list<or<operator_param, operator_param>>) {
  require { r0 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | left(param)  -> (* add *)
        do_require(param.opp_owner = caller , CALLER_NOT_OWNER);
        operator.add({
          oaddr  = param.opp_operator; 
          otoken = param.opp_token_id; 
          oowner = param.opp_owner
        })
      | right(param) -> (* remove *)
        do_require(param.opp_owner = caller , CALLER_NOT_OWNER);
        operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
      end;
    done;
  }
}

/**
* Adds or removes an operator for *all* transfers for caller's tokens
* @param upl list of add or remove operator address
*/ 
entry update_operators_for_all (upl : list<or<address, address>>) {
  require { r1 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | left(op)  -> (* add *)
        operator_for_all.add({fa_oaddr = op; fa_oowner = caller})
      | right(op) -> (* remove *)
        operator_for_all.remove((op, caller))
      end;
    done;
  }
}

function minter_is_operator_check(%from: address, td: transfer_destination) : bool {
  return
  (if not token_metadata[td.token_id_dest].minter_is_operator then false
  else if caller <> token_metadata[td.token_id_dest].token_minter then false
  else true
  )
}

function check_owner_and_operator(txs : list<address * list<transfer_destination>>) : bool {
  var res = true;

  for tx in txs do
    var %from = tx[0];
    var tds = tx[1];
    for td in tds do
      res &= 
        if caller <> %from then 
          (operator.contains((caller,td.token_id_dest,%from)) or 
           operator_for_all.contains((caller, %from)) or minter_is_operator_check(%from, td)) 
        else 
          ledger.contains((td.token_id_dest, caller));
    done
  done;
  return res
}


function transfer_rules_check(%from: address, td: transfer_destination) : bool {
  do_require(inter_transfer_allowed(%from, td), NO_INTER_TRANSFER);
  do_require(minter_is_reciever_after_expiry(%from, td), NO_INTER_TRANSFER_AFTER_EXPIRY);
  do_require(is_not_frozen(td.token_id_dest), TOKEN_FROZEN);
  return true
}

//----------------------------------------------------------------------------
// Feeless transfer (one step, )
//----------------------------------------------------------------------------

/**
* Transfers tokens with permits 
* @param batch list of pairs of permits (key and signature) and transfer specification
* Note: pk public key that signed 
* Note: signature contract address * chain id * counter * data
* Note: counter is to prevent replay attack
* Note: a transfer specification is a list of pairs of 'from' address and transfer destination
* Note: a transfer destination has a 'to' address, a token id and an amount
*/ 
entry transfer_gasless (batch : list<list<address * list<transfer_destination>> * (key * signature)>) {
  require { r8 : is_not_paused() }
  effect {
    for b in batch do
      var pk  = b[1][0];
      var sig = b[1][1];
      var pkh = key_to_address(pk);

      var lcounter = if permits.contains(pkh) then permits[pkh].counter else 0;
      var data : bytes = pack((self_address, lcounter, blake2b(pack(b[0]))));
      if not check_signature(pk, sig, data) then fail((MISSIGNED, data));
      permits.add_update(pkh, { counter = (lcounter + 1)});

      for tx in b[0] do
        var %from = tx[0];
        var tds = tx[1];
        do_require(pkh = %from, (SIGNER_NOT_FROM, (pkh, %from)));
        for td in tds do
          var can_transfer = transfer_rules_check(%from, td);
          var %to = td.to_dest;
          (* set token ownership *)
          var tokenid = td.token_id_dest;
          var amount = ledger[(tokenid, %from)].lamount;
          if td.token_amount_dest > amount then
            fail(FA2_INSUFFICIENT_BALANCE)
          else if td.token_amount_dest = amount then
            ledger.remove((tokenid, %from))
          else
            ledger.update((tokenid, %from), { lamount -= td.token_amount_dest });
          ledger.add_update((tokenid, td.to_dest), { lamount += td.token_amount_dest })
        done;
      done
    done
  }
}

/**
* Transfers tokens
* @param txs list of pairs of 'from' address and transfer destination
* Note : a transfer destination has a 'to' address, a token id and an amount
* Note : if caller is not 'from' nor operator, it checks if there is a permit
*/
entry %transfer (txs : list<address * list<transfer_destination>>) {
  require { r4 : is_not_paused() }
  effect {

    // making sure permissions checkout
    if not check_owner_and_operator(txs) then fail(FA2_NOT_OPERATOR);

    // make transfers
    for tx in txs do
      var %from = tx[0];
      var tds = tx[1];
      for td in tds do
        var can_transfer = transfer_rules_check(%from, td);
        (* set token ownership *)
        var tokenid = td.token_id_dest;
        var amount = ledger[(tokenid, %from)].lamount;
        if td.token_amount_dest > amount then
          fail(FA2_INSUFFICIENT_BALANCE)
        else if td.token_amount_dest = amount then
          ledger.remove((tokenid, %from))
        else
          ledger.update((tokenid, %from), { lamount -= td.token_amount_dest });
        ledger.add_update((tokenid, td.to_dest), { lamount += td.token_amount_dest })
      done;
    done
  }
}

//----------------------------------------------------------------------------
// Mint & burn
//----------------------------------------------------------------------------

/**
* Mint new token
* @param itokenid token id to mint
* @param rate interest percent earned on token at the end of duration
* @param iamount amount of token
* @param itokenMetadata token metadata
*/
entry mint (itokenid : nat, rate : rational, iamount : nat, expiration: date, custodial: bool, itokenMetadata: map<string, bytes>) {
  called by minters
  require {
    r11: is_not_paused();
    r12: expiration > now 
   }
  effect {
    // add expiration date
    token_metadata.add({
      ftoken_metadata = itokenid; 
      token_id = itokenid; 
      token_minter = caller; 
      token_expiration_date = expiration;
      token_interest = rate;
      token_info = itokenMetadata;
      token_itr_paused = custodial;
      minter_is_operator  = custodial
    });
    // make sure token hasnt been minted already
    if (ledger.contains((itokenid, caller))) then fail(NO_DOUBLE_MINTING);
    // minted directly to the address of the minter
    ledger.add({ ltoken = itokenid; lowner = caller; lamount = iamount });
    // add token to minters token lists
    minters.update(caller, { tokens_minted = prepend(minters[caller].tokens_minted, itokenid) })
  }
}

/**
* Burn an amount of token
* @param itokenid token to burn
* @param iamount amount to burn 
*/
entry burn(itokenid : nat, iamount : nat) {
  called by minters
  require { r2 : is_not_paused() }
  effect {
    if (ledger.contains((itokenid, caller))) then
    begin
      var vamount = ledger[(itokenid, caller)].lamount;
      if (vamount > iamount)
      then ledger.update((itokenid, caller), { lamount -= iamount })
      else if (vamount = iamount)
        then ledger.remove((itokenid, caller))
        else fail(FA2_INSUFFICIENT_BALANCE);
    end
    else
      fail(FA2_INSUFFICIENT_BALANCE);
  }
}

//----------------------------------------------------------------------------
// Getters (TZIP4 view) & views (Hangzhou)
//----------------------------------------------------------------------------

/**
* TZIP-4 view (aka Archetype getter) to return the list of balances for each balance request
* @param requests list of balance requests
*/
getter balance_of (requests : list<balance_of_request>) : list<balance_of_response> {
  return map(requests, br -> {
    request = br;
    balance_ = (
      if ledger.contains((br.btoken_id, br.bo_owner))
      then ledger[(br.btoken_id, br.bo_owner)].lamount
      else 0
    )
  })
}

